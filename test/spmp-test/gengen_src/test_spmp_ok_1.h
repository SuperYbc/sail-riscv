/*
 * File automatically generated by
 * gengen 1.4.2 by Lorenzo Bettini 
 * http://www.gnu.org/software/gengen
 */

#ifndef SPMP_OK_GEN_CLASS_H
#define SPMP_OK_GEN_CLASS_H

#include <string>
#include <iostream>

using std::string;
using std::ostream;

class spmp_ok_gen_class
{
 protected:
  int create_spmp_cfg;
  int expected_rw_fail;
  int expected_x_fail;
  int spmp_addr_offset;
  int spmp_rw;
  int spmp_s;
  int spmp_x;
  int sum;
  int switch_u_mode;
  string tag;

 public:
  spmp_ok_gen_class() :
    create_spmp_cfg (0), expected_rw_fail (0), expected_x_fail (0), spmp_addr_offset (0), spmp_rw (0), spmp_s (0), spmp_x (0), sum (0), switch_u_mode (0)
  {
  }
  
  spmp_ok_gen_class(int _create_spmp_cfg, int _expected_rw_fail, int _expected_x_fail, int _spmp_addr_offset, int _spmp_rw, int _spmp_s, int _spmp_x, int _sum, int _switch_u_mode, const string &_tag) :
    create_spmp_cfg (_create_spmp_cfg), expected_rw_fail (_expected_rw_fail), expected_x_fail (_expected_x_fail), spmp_addr_offset (_spmp_addr_offset), spmp_rw (_spmp_rw), spmp_s (_spmp_s), spmp_x (_spmp_x), sum (_sum), switch_u_mode (_switch_u_mode), tag (_tag)
  {
  }

  void set_create_spmp_cfg(int _create_spmp_cfg)
  {
    create_spmp_cfg = _create_spmp_cfg;
  }

  void set_expected_rw_fail(int _expected_rw_fail)
  {
    expected_rw_fail = _expected_rw_fail;
  }

  void set_expected_x_fail(int _expected_x_fail)
  {
    expected_x_fail = _expected_x_fail;
  }

  void set_spmp_addr_offset(int _spmp_addr_offset)
  {
    spmp_addr_offset = _spmp_addr_offset;
  }

  void set_spmp_rw(int _spmp_rw)
  {
    spmp_rw = _spmp_rw;
  }

  void set_spmp_s(int _spmp_s)
  {
    spmp_s = _spmp_s;
  }

  void set_spmp_x(int _spmp_x)
  {
    spmp_x = _spmp_x;
  }

  void set_sum(int _sum)
  {
    sum = _sum;
  }

  void set_switch_u_mode(int _switch_u_mode)
  {
    switch_u_mode = _switch_u_mode;
  }

  void set_tag(const string &_tag)
  {
    tag = _tag;
  }

  void generate_spmp_ok(ostream &stream, unsigned int indent = 0)
  {
    string indent_str (indent, ' ');
    indent = 0;
  
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * ";
    stream << tag;
    stream << "\n";
    stream << indent_str;
    stream << " * Generated from gen_spmp_test.cc and test_spmp_ok_1.cc_skel.";
    stream << "\n";
    stream << indent_str;
    stream << " * ";
    stream << "\n";
    stream << indent_str;
    stream << " * This test program is expected to start executed from M mode.";
    stream << "\n";
    stream << indent_str;
    stream << " * That will be easier for us to deal with spmp/pmp exception for test.";
    stream << "\n";
    stream << indent_str;
    stream << " * ";
    stream << "\n";
    stream << indent_str;
    stream << " * Remarks:";
    stream << "\n";
    stream << indent_str;
    stream << " * - Shared regions are not covered and will be tested separately";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * Macros from encoding.h";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "#define MSTATUS_MPP         0x00001800";
    stream << "\n";
    stream << indent_str;
    stream << "#define SSTATUS_SPP         0x00000100";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_R     0x01";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_W     0x02";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_X     0x04";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_A     0x18";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_L     0x80";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_SHIFT 2";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_TOR   0x08";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_NA4   0x10";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_NAPOT 0x18";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define SPMP_S    0x80";
    stream << "\n";
    stream << indent_str;
    stream << "#define SSTATUS_SUM         0x00040000";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPCFG0 0x1a0";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPCFG1 0x1a1";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPCFG2 0x1a2";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPCFG3 0x1a3";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR0 0x1b0";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR1 0x1b1";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR2 0x1b2";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR3 0x1b3";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR4 0x1b4";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR5 0x1b5";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR6 0x1b6";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR7 0x1b7";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR8 0x1b8";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR9 0x1b9";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR10 0x1ba";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR11 0x1bb";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR12 0x1bc";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR13 0x1bd";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR14 0x1be";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR15 0x1bf";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define TEST_RW 1";
    stream << "\n";
    stream << indent_str;
    stream << "#define TEST_FETCH 1";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define CAUSE_LOAD_ACCESS 0x5";
    stream << "\n";
    stream << indent_str;
    stream << "#define CAUSE_STORE_ACCESS 0x7";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define CAUSE_FETCH_PAGE_FAULT 0xc";
    stream << "\n";
    stream << indent_str;
    stream << "#define CAUSE_LOAD_PAGE_FAULT 0xd";
    stream << "\n";
    stream << indent_str;
    stream << "#define CAUSE_STORE_PAGE_FAULT 0xf";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "typedef unsigned long reg_t;";
    stream << "\n";
    stream << indent_str;
    stream << "typedef unsigned long uintptr_t;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * functions from syscalls.c";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "#if PRINTF_SUPPORTED";
    stream << "\n";
    stream << indent_str;
    stream << "int printf(const char* fmt, ...);";
    stream << "\n";
    stream << indent_str;
    stream << "#else";
    stream << "\n";
    stream << indent_str;
    stream << "#define printf(...)";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "void __attribute__((noreturn)) tohost_exit(uintptr_t code);";
    stream << "\n";
    stream << indent_str;
    stream << "void exit(int code);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * local status";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "#define TEST_MEM_START 0x200000";
    stream << "\n";
    stream << indent_str;
    stream << "#define TEST_MEM_END 0x240000";
    stream << "\n";
    stream << indent_str;
    stream << "#define U_MEM_END (TEST_MEM_END + 0x10000)";
    stream << "\n";
    stream << indent_str;
    stream << "#define S_MEM_END (0x280000 + 0x10000)";
    stream << "\n";
    stream << indent_str;
    stream << "#define FAKE_ADDRESS 0x10000000";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static const unsigned long expected_rw_fail = ";
    stream << expected_rw_fail;
    stream << ";";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".data_smode\"), noinline))";
    stream << "\n";
    stream << indent_str;
    stream << "static unsigned actual_rw_fail = 0;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static const unsigned long expected_x_fail = ";
    stream << expected_x_fail;
    stream << ";";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/* Note: the test code will try to access x_fail in s-mode, this will not be prevented by PMP";
    stream << "\n";
    stream << indent_str;
    stream << "         As PMP gives all permission up.";
    stream << "\n";
    stream << indent_str;
    stream << "*/";
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".data_smode\"), noinline))";
    stream << "\n";
    stream << indent_str;
    stream << "static unsigned actual_x_fail = 0;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static void checkTestResult(void);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * override syscalls.c.";
    stream << "\n";
    stream << indent_str;
    stream << " *  currently simply skip to nexp instruction";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "uintptr_t handle_trap(uintptr_t cause, uintptr_t epc, uintptr_t regs[32])";
    stream << "\n";
    stream << indent_str;
    stream << "{";
    stream << "\n";
    stream << indent_str;
    stream << "    if (epc >= TEST_MEM_START && epc < TEST_MEM_END) {";
    stream << "\n";
    stream << indent_str;
    stream << "        asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "        actual_x_fail = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "        checkTestResult();";
    stream << "\n";
    stream << indent_str;
    stream << "    //} else if (cause == CAUSE_LOAD_ACCESS || cause == CAUSE_STORE_ACCESS) {";
    stream << "\n";
    stream << indent_str;
    stream << "    } else if (cause == CAUSE_LOAD_PAGE_FAULT || cause == CAUSE_STORE_PAGE_FAULT) {";
    stream << "\n";
    stream << indent_str;
    stream << "        reg_t addr;";
    stream << "\n";
    stream << indent_str;
    stream << "        asm volatile (\"csrr %0, mtval\\n\" : \"=r\"(addr));";
    stream << "\n";
    stream << indent_str;
    stream << "        printf(\"addr = 0x%x\\n\", addr);";
    stream << "\n";
    stream << indent_str;
    stream << "        if (addr >= TEST_MEM_START && addr < TEST_MEM_END) {";
    stream << "\n";
    stream << indent_str;
    stream << "            actual_rw_fail = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "            return epc + 4;";
    stream << "\n";
    stream << indent_str;
    stream << "        }";
    stream << "\n";
    stream << indent_str;
    indent = 8;
    stream << "        ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "        if (addr == FAKE_ADDRESS) {";
    stream << "\n";
    stream << indent_str;
    stream << "            asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "            asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "            checkTestResult();";
    stream << "\n";
    stream << indent_str;
    stream << "        }";
    stream << "\n";
    stream << indent_str;
    stream << "    } else if (cause == CAUSE_LOAD_ACCESS || cause == CAUSE_STORE_ACCESS) {";
    stream << "\n";
    stream << indent_str;
    stream << "        reg_t addr;";
    stream << "\n";
    stream << indent_str;
    stream << "        asm volatile (\"csrr %0, mtval\\n\" : \"=r\"(addr));";
    stream << "\n";
    stream << indent_str;
    stream << "        if (addr == FAKE_ADDRESS) {";
    stream << "\n";
    stream << indent_str;
    stream << "            asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "            asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "            checkTestResult();";
    stream << "\n";
    stream << indent_str;
    stream << "        }";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    printf(\"cause = %ld, epc = 0x%lx\\n\", cause, epc);";
    stream << "\n";
    stream << indent_str;
    stream << "    tohost_exit(1337);";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "// switch (eret) to U mode and resume next PC";
    stream << "\n";
    stream << indent_str;
    stream << "static void switch_to_U() {";
    stream << "\n";
    stream << indent_str;
    stream << "#if 0 //switch to U mode from M mode";
    stream << "\n";
    stream << indent_str;
    stream << "    reg_t tmp;";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "            \"li %0, %1\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrc mstatus, t0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tla %0, try_access_umode \\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrw mepc, %0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tli sp, %2\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tmret\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            : \"=r\"(tmp) : \"n\"(MSTATUS_MPP), \"n\"(U_MEM_END) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#else //switch to U mode from S mode";
    stream << "\n";
    stream << indent_str;
    stream << "    reg_t tmp;";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "            \"li %0, %1\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrc sstatus, t0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tla %0, try_access_umode \\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrw sepc, %0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tli sp, %2\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tsret\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            : \"=r\"(tmp) : \"n\"(SSTATUS_SPP), \"n\"(U_MEM_END) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static void switch_mode() {";
    stream << "\n";
    stream << indent_str;
    stream << "#if ";
    stream << switch_u_mode;
    stream << "\n";
    stream << indent_str;
    stream << "    switch_to_U();";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static void switch_smode() {";
    stream << "\n";
    stream << indent_str;
    stream << "#if 0";
    stream << "\n";
    stream << indent_str;
    stream << "    reg_t tmp;";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "            \"li %0, %1\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrc mstatus, t0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tla %0, smode_main\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrw mepc, %0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tli sp, %2\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tmret\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            : \"=r\"(tmp) : \"n\"(MSTATUS_MPP), \"n\"(S_MEM_END) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#else";
    stream << "\n";
    stream << indent_str;
    stream << "	reg_t tmp;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "	\"csrr %0, mstatus\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "	: \"=r\"(tmp)::\"memory\"); ";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	tmp = tmp & ~(MSTATUS_MPP); // clear MPP bits";
    stream << "\n";
    stream << indent_str;
    stream << "	tmp = tmp | (0x1 << 11);    // set MPP to S-mode";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "	\"csrw mstatus, %0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "	::\"r\"(tmp) :\"memory\"); ";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	//clear satp (to disable paging)";
    stream << "\n";
    stream << indent_str;
    stream << "	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "	\"csrw satp, x0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "	:::\"memory\"); ";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tla %0, smode_main\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrw mepc, %0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tli sp, %1\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tmret\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            : \"=r\"(tmp) : \"n\"(S_MEM_END) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".text_test_foo\"), noinline))";
    stream << "\n";
    stream << indent_str;
    stream << "static void target_foo() {";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    actual_x_fail = 0;";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * avoid to access actual_x_fail lies in M mode";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".text_test_foo\"), noinline))";
    stream << "\n";
    stream << indent_str;
    stream << "static void target_foo_umode() {";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".data_test_arr\"), aligned(8)))";
    stream << "\n";
    stream << indent_str;
    stream << "static volatile unsigned char target_arr[100] = {";
    stream << "\n";
    stream << indent_str;
    stream << "        1,2,3,4,5,6,7,8,";
    stream << "\n";
    stream << indent_str;
    stream << "};";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * On processor_t::reset():";
    stream << "\n";
    stream << indent_str;
    stream << " *  - set_csr(CSR_PMPADDR0, ~reg_t(0));";
    stream << "\n";
    stream << indent_str;
    stream << " *    set_csr(CSR_PMPCFG0, PMP_R | PMP_W | PMP_X | PMP_NAPOT);";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "static void set_cfg() {";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    // Give all the memory accessible to the S/U modes";
    stream << "\n";
    stream << indent_str;
    stream << "    //asm volatile (\"csrw pmpaddr0, %0\\n\" :: \"r\"(~reg_t(0)) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (\"csrw pmpaddr0, %0\\n\" :: \"r\"((0x400000>>2)-1) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "    /* We can not give permission to access all addresses because we rely on fake addr for trap */";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (\"csrw pmpcfg0,  %0\\n\" :: \"r\"(PMP_R | PMP_W | PMP_X | PMP_NAPOT) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // currently dummy since tlb flushed when set_csr on mseccfg";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (\"fence.i \\n\");";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "// from pmp_ok() side,W/R/X is similar";
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".text_smode\")))";
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((noinline))";
    stream << "\n";
    stream << indent_str;
    stream << "static void try_access() {";
    stream << "\n";
    stream << indent_str;
    stream << "#if TEST_RW";
    stream << "\n";
    stream << indent_str;
    stream << "    target_arr[0] += 1;";
    stream << "\n";
    stream << indent_str;
    stream << "    //const unsigned long delta = 0x1020304005060708UL;";
    stream << "\n";
    stream << indent_str;
    stream << "#define DELTA 0x1020304005060708UL";
    stream << "\n";
    stream << indent_str;
    stream << "    *(long *)target_arr += DELTA;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    if (*(long *)target_arr != 0x0807060504030201UL + DELTA + 1) {";
    stream << "\n";
    stream << indent_str;
    stream << "        actual_rw_fail = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#if TEST_FETCH";
    stream << "\n";
    stream << indent_str;
    stream << "    actual_x_fail = 1;  // reset inside target_foo()";
    stream << "\n";
    stream << indent_str;
    stream << "    target_foo();";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "// in case mml set, printf cannot be used in U mode";
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".text_umode\")))";
    stream << "\n";
    stream << indent_str;
    stream << "void try_access_umode() {";
    stream << "\n";
    stream << indent_str;
    stream << "#if TEST_RW";
    stream << "\n";
    stream << indent_str;
    stream << "    target_arr[0] += 1;";
    stream << "\n";
    stream << indent_str;
    stream << "//    const unsigned long delta = 0x1020304005060708UL;";
    stream << "\n";
    stream << indent_str;
    stream << "//    *(long *)target_arr += delta;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "//    if (*(long *)target_arr != 0x0807060504030201UL + delta + 1) {";
    stream << "\n";
    stream << indent_str;
    stream << "//        actual_rw_fail = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "//    }";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#if TEST_FETCH";
    stream << "\n";
    stream << indent_str;
    stream << "    target_foo_umode();";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    /*";
    stream << "\n";
    stream << indent_str;
    stream << "     * switch to M mode by invoking a write access fault for special address.";
    stream << "\n";
    stream << indent_str;
    stream << "     */ ";
    stream << "\n";
    stream << indent_str;
    stream << "    *(char *)(FAKE_ADDRESS) = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "// S-mode text";
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".text_smode\")))";
    stream << "\n";
    stream << indent_str;
    stream << "void smode_main() {";
    stream << "\n";
    stream << indent_str;
    stream << "	/* configure sPMP */";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "   	/*";
    stream << "\n";
    stream << indent_str;
    stream << "   	 * Here ";
    stream << "@";
    stream << "spmp_addr_offset:int";
    stream << "@";
    stream << " is to create an address mismatch";
    stream << "\n";
    stream << indent_str;
    stream << "   	 * And ";
    stream << "@";
    stream << "create_spmp_cfg:int";
    stream << "@";
    stream << " is to create cfg mismatch.";
    stream << "\n";
    stream << indent_str;
    stream << "   	 */";
    stream << "\n";
    stream << indent_str;
    stream << "#if 0";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b4, %0 \\n\" :: \"r\"(S_MEM_END >> 2) : \"memory\"); //spmpaddr4";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b3, %0 \\n\" :: \"r\"(U_MEM_END >> 2) : \"memory\"); //spmpaddr3";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b2, %0 \\n\" :: \"r\"(TEST_MEM_END >> 2) : \"memory\"); //spmpaddr2";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b1, %0 \\n\" :: \"r\"((TEST_MEM_START + ";
    stream << spmp_addr_offset;
    stream << ") >> 2) : \"memory\"); //spmpaddr1";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b0, %0 \\n\" :: \"r\"((TEST_MEM_START >> 3) - 1) : \"memory\"); //spmpaddr0";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    	//FIXME: legacy code which gives the M-mode memory permissions ";
    stream << "\n";
    stream << indent_str;
    stream << "	//       It works because sPMP allows access (from S-mode) by default";
    stream << "\n";
    stream << indent_str;
    stream << "	reg_t cfg0 = (PMP_R | PMP_W | PMP_X | PMP_NAPOT);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	reg_t cfg1 = (PMP_R | PMP_W | PMP_X | SPMP_S | PMP_TOR);   // for S_MEM";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    	cfg0 |= (PMP_R | PMP_W | PMP_X | PMP_TOR) << 24;    // for U_MEM";
    stream << "\n";
    stream << indent_str;
    stream << "#if ";
    stream << create_spmp_cfg;
    stream << "\n";
    stream << indent_str;
    stream << "    	cfg0 |= ((";
    stream << spmp_rw;
    stream << " ? (PMP_R | PMP_W)  : 0) | (";
    stream << spmp_x;
    stream << " ? PMP_X : 0) | PMP_TOR | (";
    stream << spmp_s;
    stream << " ? SPMP_S : 0)) << 16;";
    stream << "\n";
    stream << indent_str;
    stream << "#endif   ";
    stream << "\n";
    stream << indent_str;
    stream << "    	asm volatile (\"csrw 0x1a0, %0 \\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "    	            :";
    stream << "\n";
    stream << indent_str;
    stream << "    	            : \"r\"(cfg0)";
    stream << "\n";
    stream << indent_str;
    stream << "    	            : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#else";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b3, %0 \\n\" :: \"r\"(S_MEM_END >> 2) : \"memory\"); //spmpaddr3";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b2, %0 \\n\" :: \"r\"(U_MEM_END >> 2) : \"memory\"); //spmpaddr2";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b1, %0 \\n\" :: \"r\"(TEST_MEM_END >> 2) : \"memory\"); //spmpaddr1";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b0, %0 \\n\" :: \"r\"((TEST_MEM_START + ";
    stream << spmp_addr_offset;
    stream << ") >> 2) : \"memory\"); //spmpaddr0";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	//reg_t cfg0 = (PMP_R | PMP_W | PMP_X | PMP_NAPOT) << 24; // for S_MEM";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	/* This is a shared R/W/X regions because we do not have R/W/X for S-mode only */";
    stream << "\n";
    stream << indent_str;
    stream << "	reg_t cfg0 = (!PMP_R | !PMP_W | !PMP_X | SPMP_S | PMP_TOR) << 24;   // for S_MEM";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    	cfg0 |= (PMP_R | PMP_W | PMP_X | PMP_TOR) << 16;    // for U_MEM";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#if ";
    stream << create_spmp_cfg;
    stream << "\n";
    stream << indent_str;
    stream << "    	cfg0 |= ((";
    stream << spmp_rw;
    stream << " ? (PMP_R | PMP_W)  : 0) | (";
    stream << spmp_x;
    stream << " ? PMP_X : 0) | PMP_TOR | (";
    stream << spmp_s;
    stream << " ? SPMP_S : 0)) << 8;";
    stream << "\n";
    stream << indent_str;
    stream << "#endif   ";
    stream << "\n";
    stream << indent_str;
    stream << "    	asm volatile (\"csrw 0x1a0, %0 \\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "    	            :";
    stream << "\n";
    stream << indent_str;
    stream << "    	            : \"r\"(cfg0)";
    stream << "\n";
    stream << indent_str;
    stream << "    	            : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	//configure SUM bit";
    stream << "\n";
    stream << indent_str;
    stream << "#if ";
    stream << sum;
    stream << "\n";
    stream << indent_str;
    stream << "	//set SUM";
    stream << "\n";
    stream << indent_str;
    stream << "    	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "    	        \"li t0, 0x00040000\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "    	        \"\\tcsrs sstatus, t0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "    	        ::: \"t0\", \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#else";
    stream << "\n";
    stream << indent_str;
    stream << "	//clear SUM";
    stream << "\n";
    stream << indent_str;
    stream << "    	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "    	        \"li t0, 0x00040000\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "    	        \"\\tcsrc sstatus, t0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "    	        :::\"t0\", \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	/* Test */";
    stream << "\n";
    stream << indent_str;
    stream << "    	switch_mode();  // in case swith to u mode, branch to try_access_umode directly";
    stream << "\n";
    stream << indent_str;
    stream << "    	try_access();";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	/* End */";
    stream << "\n";
    stream << indent_str;
    stream << "    	checkTestResult();";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static void checkTestResult() {";
    stream << "\n";
    stream << indent_str;
    stream << "    int ret = 0;";
    stream << "\n";
    stream << indent_str;
    stream << "    if (expected_rw_fail != actual_rw_fail) {";
    stream << "\n";
    stream << indent_str;
    stream << "        ret += 1;";
    stream << "\n";
    stream << indent_str;
    stream << "        printf(\"Read/write test fail, expected %d, actual %d.\\n\", expected_rw_fail, actual_rw_fail);";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    if (expected_x_fail != actual_x_fail) {";
    stream << "\n";
    stream << indent_str;
    stream << "        ret += 2;";
    stream << "\n";
    stream << indent_str;
    stream << "        printf(\"Fetch test fail, expected %d, actual %d.\\n\", expected_x_fail, actual_x_fail);";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    printf(\"Test done, exit %d.\\n\", ret);";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    exit(ret); ";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "int main() {";
    stream << "\n";
    stream << indent_str;
    stream << "    // assert in M mode";
    stream << "\n";
    stream << indent_str;
    stream << "    set_cfg();";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    switch_smode();";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    return 0; // assert 0";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
  }
};

#endif // SPMP_OK_GEN_CLASS_H
