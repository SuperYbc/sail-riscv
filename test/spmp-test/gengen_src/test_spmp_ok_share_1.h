/*
 * File automatically generated by
 * gengen 1.4.2 by Lorenzo Bettini 
 * http://www.gnu.org/software/gengen
 */

#ifndef SPMP_OK_SHARE_GEN_CLASS_H
#define SPMP_OK_SHARE_GEN_CLASS_H

#include <string>
#include <iostream>

using std::string;
using std::ostream;

class spmp_ok_share_gen_class
{
 protected:
  int enable_umode_test;
  int expected_r_fail;
  int expected_w_fail;
  int expected_x_fail;
  int spmp_addr_offset;
  int spmp_r;
  int spmp_s;
  int spmp_w;
  int spmp_x;
  int sum;
  string tag;
  int typex;

 public:
  spmp_ok_share_gen_class() :
    enable_umode_test (0), expected_r_fail (0), expected_w_fail (0), expected_x_fail (0), spmp_addr_offset (0), spmp_r (0), spmp_s (0), spmp_w (0), spmp_x (0), sum (0), typex (0)
  {
  }
  
  spmp_ok_share_gen_class(int _enable_umode_test, int _expected_r_fail, int _expected_w_fail, int _expected_x_fail, int _spmp_addr_offset, int _spmp_r, int _spmp_s, int _spmp_w, int _spmp_x, int _sum, const string &_tag, int _typex) :
    enable_umode_test (_enable_umode_test), expected_r_fail (_expected_r_fail), expected_w_fail (_expected_w_fail), expected_x_fail (_expected_x_fail), spmp_addr_offset (_spmp_addr_offset), spmp_r (_spmp_r), spmp_s (_spmp_s), spmp_w (_spmp_w), spmp_x (_spmp_x), sum (_sum), tag (_tag), typex (_typex)
  {
  }

  void set_enable_umode_test(int _enable_umode_test)
  {
    enable_umode_test = _enable_umode_test;
  }

  void set_expected_r_fail(int _expected_r_fail)
  {
    expected_r_fail = _expected_r_fail;
  }

  void set_expected_w_fail(int _expected_w_fail)
  {
    expected_w_fail = _expected_w_fail;
  }

  void set_expected_x_fail(int _expected_x_fail)
  {
    expected_x_fail = _expected_x_fail;
  }

  void set_spmp_addr_offset(int _spmp_addr_offset)
  {
    spmp_addr_offset = _spmp_addr_offset;
  }

  void set_spmp_r(int _spmp_r)
  {
    spmp_r = _spmp_r;
  }

  void set_spmp_s(int _spmp_s)
  {
    spmp_s = _spmp_s;
  }

  void set_spmp_w(int _spmp_w)
  {
    spmp_w = _spmp_w;
  }

  void set_spmp_x(int _spmp_x)
  {
    spmp_x = _spmp_x;
  }

  void set_sum(int _sum)
  {
    sum = _sum;
  }

  void set_tag(const string &_tag)
  {
    tag = _tag;
  }

  void set_typex(int _typex)
  {
    typex = _typex;
  }

  void generate_spmp_ok_share(ostream &stream, unsigned int indent = 0)
  {
    string indent_str (indent, ' ');
    indent = 0;
  
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * ";
    stream << tag;
    stream << "\n";
    stream << indent_str;
    stream << " * Generated from gen_pmp_test.cc and test_pmp_ok_share_1.cc_skel.";
    stream << "\n";
    stream << indent_str;
    stream << " * ";
    stream << "\n";
    stream << indent_str;
    stream << " * This test program is to test spmp_ok() when share mode (RW=01, SRWX: 1000, SRWX: 1111).";
    stream << "\n";
    stream << indent_str;
    stream << " * Based on other test cases for mseccfg stiky bits, this test expects following:";
    stream << "\n";
    stream << indent_str;
    stream << " * - RW = 01/SRWX:1000/SRWX:1111.";
    stream << "\n";
    stream << indent_str;
    stream << " * - Regine matched.";
    stream << "\n";
    stream << indent_str;
    stream << " * ";
    stream << "\n";
    stream << indent_str;
    stream << " * Remarks:";
    stream << "\n";
    stream << indent_str;
    stream << " * - ";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * Macros from encoding.h";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "#define MSTATUS_MPP         0x00001800";
    stream << "\n";
    stream << indent_str;
    stream << "#define SSTATUS_SPP         0x00000100";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_R     0x01";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_W     0x02";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_X     0x04";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_A     0x18";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_L     0x80";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_SHIFT 2";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_TOR   0x08";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_NA4   0x10";
    stream << "\n";
    stream << indent_str;
    stream << "#define PMP_NAPOT 0x18";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define SPMP_S    0x80";
    stream << "\n";
    stream << indent_str;
    stream << "#define SSTATUS_SUM         0x00040000";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPCFG0 0x1a0";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPCFG1 0x1a1";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPCFG2 0x1a2";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPCFG3 0x1a3";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR0 0x1b0";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR1 0x1b1";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR2 0x1b2";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR3 0x1b3";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR4 0x1b4";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR5 0x1b5";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR6 0x1b6";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR7 0x1b7";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR8 0x1b8";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR9 0x1b9";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR10 0x1ba";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR11 0x1bb";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR12 0x1bc";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR13 0x1bd";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR14 0x1be";
    stream << "\n";
    stream << indent_str;
    stream << "#define CSR_SPMPADDR15 0x1bf";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define TEST_RW (1 - ";
    stream << typex;
    stream << ")";
    stream << "\n";
    stream << indent_str;
    stream << "#define TEST_FETCH (";
    stream << typex;
    stream << ")";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define CAUSE_LOAD_ACCESS 0x5";
    stream << "\n";
    stream << indent_str;
    stream << "#define CAUSE_STORE_ACCESS 0x7";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define CAUSE_FETCH_PAGE_FAULT 0xc";
    stream << "\n";
    stream << indent_str;
    stream << "#define CAUSE_LOAD_PAGE_FAULT 0xd";
    stream << "\n";
    stream << indent_str;
    stream << "#define CAUSE_STORE_PAGE_FAULT 0xf";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "typedef unsigned long reg_t;";
    stream << "\n";
    stream << indent_str;
    stream << "typedef unsigned long uintptr_t;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * functions from syscalls.c";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "#if PRINTF_SUPPORTED";
    stream << "\n";
    stream << indent_str;
    stream << "int printf(const char* fmt, ...);";
    stream << "\n";
    stream << indent_str;
    stream << "#else";
    stream << "\n";
    stream << indent_str;
    stream << "#define printf(...)";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "void __attribute__((noreturn)) tohost_exit(uintptr_t code);";
    stream << "\n";
    stream << indent_str;
    stream << "void exit(int code);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * local status";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "#define TEST_MEM_START 0x200000";
    stream << "\n";
    stream << indent_str;
    stream << "#define TEST_MEM_END 0x240000";
    stream << "\n";
    stream << indent_str;
    stream << "#define U_MEM_END (TEST_MEM_END + 0x10000)";
    stream << "\n";
    stream << indent_str;
    stream << "#define S_MEM_END (0x280000 + 0x10000)";
    stream << "\n";
    stream << indent_str;
    stream << "#define FAKE_ADDRESS 0x10000000";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static const unsigned long expected_r_fail = ";
    stream << expected_r_fail;
    stream << ";";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".data_smode\"), noinline))";
    stream << "\n";
    stream << indent_str;
    stream << "static unsigned actual_r_fail = 0;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static const unsigned long expected_w_fail = ";
    stream << expected_w_fail;
    stream << ";";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".data_smode\"), noinline))";
    stream << "\n";
    stream << indent_str;
    stream << "static unsigned actual_w_fail = 0;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static const unsigned long expected_x_fail = ";
    stream << expected_x_fail;
    stream << ";";
    stream << "\n";
    stream << indent_str;
    stream << "static unsigned actual_x_fail = 0;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static void checkTestResult(void);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * override syscalls.c.";
    stream << "\n";
    stream << indent_str;
    stream << " *  currently simply skip to nexp instruction";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "uintptr_t handle_trap(uintptr_t cause, uintptr_t epc, uintptr_t regs[32])";
    stream << "\n";
    stream << indent_str;
    stream << "{";
    stream << "\n";
    stream << indent_str;
    stream << "    if (epc >= TEST_MEM_START && epc < TEST_MEM_END) {";
    stream << "\n";
    stream << indent_str;
    stream << "        asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "        actual_x_fail = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "        checkTestResult();";
    stream << "\n";
    stream << indent_str;
    stream << "    //} else if (cause == CAUSE_LOAD_ACCESS || cause == CAUSE_STORE_ACCESS) {";
    stream << "\n";
    stream << indent_str;
    stream << "    } else if (cause == CAUSE_LOAD_PAGE_FAULT || cause == CAUSE_STORE_PAGE_FAULT) {";
    stream << "\n";
    stream << indent_str;
    stream << "        reg_t addr;";
    stream << "\n";
    stream << indent_str;
    stream << "        asm volatile (\"csrr %0, mtval\\n\" : \"=r\"(addr));";
    stream << "\n";
    stream << indent_str;
    stream << "        printf(\"got spmp except, addr = 0x%x\\n\", addr);";
    stream << "\n";
    stream << indent_str;
    stream << "        if (addr >= TEST_MEM_START && addr < TEST_MEM_END) {";
    stream << "\n";
    stream << indent_str;
    stream << "            if (cause == CAUSE_LOAD_PAGE_FAULT)";
    stream << "\n";
    stream << indent_str;
    stream << "                actual_r_fail = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "            else ";
    stream << "\n";
    stream << indent_str;
    stream << "                actual_w_fail = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "            return epc + 4;";
    stream << "\n";
    stream << indent_str;
    stream << "        }";
    stream << "\n";
    stream << indent_str;
    indent = 8;
    stream << "        ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "        if (addr == FAKE_ADDRESS) {";
    stream << "\n";
    stream << indent_str;
    stream << "            asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "            asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "            checkTestResult();";
    stream << "\n";
    stream << indent_str;
    stream << "        }";
    stream << "\n";
    stream << indent_str;
    stream << "    } else if (cause == CAUSE_LOAD_ACCESS || cause == CAUSE_STORE_ACCESS) {";
    stream << "\n";
    stream << indent_str;
    stream << "        reg_t addr;";
    stream << "\n";
    stream << indent_str;
    stream << "        asm volatile (\"csrr %0, mtval\\n\" : \"=r\"(addr));";
    stream << "\n";
    stream << indent_str;
    stream << "        if (addr == FAKE_ADDRESS) {";
    stream << "\n";
    stream << indent_str;
    stream << "            asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "            asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "            checkTestResult();";
    stream << "\n";
    stream << indent_str;
    stream << "        }";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    printf(\"cause = %ld, epc = 0x%lx\\n\", cause, epc);";
    stream << "\n";
    stream << indent_str;
    stream << "    tohost_exit(1337);";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static void switch_mode_access() {";
    stream << "\n";
    stream << indent_str;
    stream << "#if 0";
    stream << "\n";
    stream << indent_str;
    stream << "    reg_t tmp;";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "            \"li %0, %1\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrc mstatus, t0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tla %0, try_access_umode \\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrw mepc, %0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tli sp, %2\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tmret\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            : \"=r\"(tmp) : \"n\"(MSTATUS_MPP), \"n\"(U_MEM_END) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#else //switch to U mode from S mode";
    stream << "\n";
    stream << indent_str;
    stream << "    reg_t tmp;";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "            \"li %0, %1\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrc sstatus, t0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tla %0, try_access_umode \\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrw sepc, %0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tli sp, %2\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tsret\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            : \"=r\"(tmp) : \"n\"(SSTATUS_SPP), \"n\"(U_MEM_END) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".text_test_foo\"), noinline))";
    stream << "\n";
    stream << indent_str;
    stream << "static void target_foo() {";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "    actual_x_fail = 0;";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * avoid to access actual_x_fail lies in M mode";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".text_test_foo\"), noinline))";
    stream << "\n";
    stream << indent_str;
    stream << "static void target_foo_umode() {";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (\"nop\");";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".data_test_arr\"), aligned(8)))";
    stream << "\n";
    stream << indent_str;
    stream << "static volatile unsigned char target_arr[100] = {";
    stream << "\n";
    stream << indent_str;
    stream << "        1,2,3,4,5,6,7,8,";
    stream << "\n";
    stream << indent_str;
    stream << "};";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "// from pmp_ok() side,W/R/X is similar";
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".text_smode\")))";
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((noinline))";
    stream << "\n";
    stream << indent_str;
    stream << "static void try_access() {";
    stream << "\n";
    stream << indent_str;
    stream << "#if TEST_RW";
    stream << "\n";
    stream << indent_str;
    stream << "    target_arr[0] += 1;";
    stream << "\n";
    stream << indent_str;
    stream << "    const unsigned long delta = 0x1020304005060708UL;";
    stream << "\n";
    stream << indent_str;
    stream << "    *(long *)target_arr += delta;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    if (actual_r_fail == 0 && actual_w_fail == 0) {";
    stream << "\n";
    stream << indent_str;
    stream << "        if (*(long *)target_arr != 0x0807060504030201UL + delta + 1) {";
    stream << "\n";
    stream << indent_str;
    stream << "            actual_r_fail = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "            actual_w_fail = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "        }";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#if TEST_FETCH";
    stream << "\n";
    stream << indent_str;
    stream << "    actual_x_fail = 1;  // reset inside target_foo()";
    stream << "\n";
    stream << indent_str;
    stream << "    target_foo();";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "// S-mode text";
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".text_smode\")))";
    stream << "\n";
    stream << indent_str;
    stream << "void smode_main() {";
    stream << "\n";
    stream << indent_str;
    stream << "	/* configure sPMP */";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "   	/*";
    stream << "\n";
    stream << indent_str;
    stream << "   	 */";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b3, %0 \\n\" :: \"r\"(S_MEM_END >> 2) : \"memory\"); //spmpaddr3";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b2, %0 \\n\" :: \"r\"(U_MEM_END >> 2) : \"memory\"); //spmpaddr2";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b1, %0 \\n\" :: \"r\"(TEST_MEM_END >> 2) : \"memory\"); //spmpaddr1";
    stream << "\n";
    stream << indent_str;
    stream << "   	asm volatile (\"csrw 0x1b0, %0 \\n\" :: \"r\"((TEST_MEM_START + ";
    stream << spmp_addr_offset;
    stream << ") >> 2) : \"memory\"); //spmpaddr0";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	//reg_t cfg0 = (PMP_R | PMP_W | PMP_X | PMP_NAPOT) << 24; // for S_MEM";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	/* This is a shared R/W/X regions because we do not have R/W/X for S-mode only */";
    stream << "\n";
    stream << indent_str;
    stream << "	reg_t cfg0 = (!PMP_R | !PMP_W | !PMP_X | SPMP_S | PMP_TOR) << 24;   // for S_MEM";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    	cfg0 |= (PMP_R | PMP_W | PMP_X | PMP_TOR) << 16;    // for U_MEM";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    	cfg0 |= ((";
    stream << spmp_r;
    stream << " ?  PMP_R:0)   //for TEST_MEM";
    stream << "\n";
    stream << indent_str;
    stream << "		| (";
    stream << spmp_w;
    stream << " ? PMP_W:0) ";
    stream << "\n";
    stream << indent_str;
    stream << "		| (";
    stream << spmp_x;
    stream << " ? PMP_X:0)";
    stream << "\n";
    stream << indent_str;
    stream << "		| PMP_TOR";
    stream << "\n";
    stream << indent_str;
    stream << "		| (";
    stream << spmp_s;
    stream << " ? SPMP_S:0)) << 8;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    	asm volatile (\"csrw 0x1a0, %0 \\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "    	            :";
    stream << "\n";
    stream << indent_str;
    stream << "    	            : \"r\"(cfg0)";
    stream << "\n";
    stream << indent_str;
    stream << "    	            : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    	// currently dummy since tlb flushed when set_csr on mseccfg";
    stream << "\n";
    stream << indent_str;
    stream << "	asm volatile (\"fence.i \\n\");";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#if 0 //SUM bit will not affect shared region behavior";
    stream << "\n";
    stream << indent_str;
    stream << "	//configure SUM bit";
    stream << "\n";
    stream << indent_str;
    stream << "#if ";
    stream << sum;
    stream << "\n";
    stream << indent_str;
    stream << "	//set SUM";
    stream << "\n";
    stream << indent_str;
    stream << "    	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "    	        \"li t0, 0x00040000\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "    	        \"\\tcsrs sstatus, t0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "    	        ::: \"t0\", \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#else";
    stream << "\n";
    stream << indent_str;
    stream << "	//clear SUM";
    stream << "\n";
    stream << indent_str;
    stream << "    	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "    	        \"li t0, 0x00040000\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "    	        \"\\tcsrc sstatus, t0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "    	        :::\"t0\", \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	/* Test */";
    stream << "\n";
    stream << indent_str;
    stream << "    //	switch_mode();  // in case swith to u mode, branch to try_access_umode directly";
    stream << "\n";
    stream << indent_str;
    stream << "    //	try_access();";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#if ";
    stream << enable_umode_test;
    stream << "\n";
    stream << indent_str;
    stream << "	switch_mode_access();   // access in umode and report final result";
    stream << "\n";
    stream << indent_str;
    stream << "#else";
    stream << "\n";
    stream << indent_str;
    stream << "	try_access();";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "	/* End */";
    stream << "\n";
    stream << indent_str;
    stream << "    	checkTestResult();";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static void switch_smode() {";
    stream << "\n";
    stream << indent_str;
    stream << "#if 0";
    stream << "\n";
    stream << indent_str;
    stream << "    reg_t tmp;";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "            \"li %0, %1\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrc mstatus, t0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tla %0, smode_main\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrw mepc, %0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tli sp, %2\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tmret\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            : \"=r\"(tmp) : \"n\"(MSTATUS_MPP), \"n\"(S_MEM_END) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "#else";
    stream << "\n";
    stream << indent_str;
    stream << "	reg_t tmp;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "	\"csrr %0, mstatus\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "	: \"=r\"(tmp)::\"memory\"); ";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	tmp = tmp & ~(MSTATUS_MPP); // clear MPP bits";
    stream << "\n";
    stream << indent_str;
    stream << "	tmp = tmp | (0x1 << 11);    // set MPP to S-mode";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "	\"csrw mstatus, %0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "	::\"r\"(tmp) :\"memory\"); ";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "	//clear satp (to disable paging)";
    stream << "\n";
    stream << indent_str;
    stream << "	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "	\"csrw satp, x0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "	:::\"memory\"); ";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    	asm volatile (";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tla %0, smode_main\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tcsrw mepc, %0\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tli sp, %1\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            \"\\tmret\\n\"";
    stream << "\n";
    stream << indent_str;
    stream << "            : \"=r\"(tmp) : \"n\"(S_MEM_END) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "/*";
    stream << "\n";
    stream << indent_str;
    stream << " * On processor_t::reset():";
    stream << "\n";
    stream << indent_str;
    stream << " *  - set_csr(CSR_PMPADDR0, ~reg_t(0));";
    stream << "\n";
    stream << indent_str;
    stream << " *    set_csr(CSR_PMPCFG0, PMP_R | PMP_W | PMP_X | PMP_NAPOT);";
    stream << "\n";
    stream << indent_str;
    stream << " */";
    stream << "\n";
    stream << indent_str;
    stream << "static void set_cfg() {";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // Give all the memory accessible to the S/U modes";
    stream << "\n";
    stream << indent_str;
    stream << "    //asm volatile (\"csrw pmpaddr0, %0\\n\" :: \"r\"(~reg_t(0)) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (\"csrw pmpaddr0, %0\\n\" :: \"r\"((0x400000>>2)-1) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "    /* We can not give permission to access all addresses because we rely on fake addr for trap */";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (\"csrw pmpcfg0,  %0\\n\" :: \"r\"(PMP_R | PMP_W | PMP_X | PMP_NAPOT) : \"memory\");";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // currently dummy since tlb flushed when set_csr on mseccfg";
    stream << "\n";
    stream << indent_str;
    stream << "    asm volatile (\"fence.i \\n\");";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "// in case mml set, printf cannot be used in U mode";
    stream << "\n";
    stream << indent_str;
    stream << "__attribute ((section(\".text_umode\")))";
    stream << "\n";
    stream << indent_str;
    stream << "void try_access_umode() {";
    stream << "\n";
    stream << indent_str;
    stream << "#if TEST_RW";
    stream << "\n";
    stream << indent_str;
    stream << "    target_arr[0] += 1;";
    stream << "\n";
    stream << indent_str;
    stream << "//    const unsigned long delta = 0x1020304005060708UL;";
    stream << "\n";
    stream << indent_str;
    stream << "//    *(long *)target_arr += delta;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "//    if (*(long *)target_arr != 0x0807060504030201UL + delta + 1) {";
    stream << "\n";
    stream << indent_str;
    stream << "//        actual_rw_fail = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "//    }";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#if TEST_FETCH";
    stream << "\n";
    stream << indent_str;
    stream << "    target_foo_umode();";
    stream << "\n";
    stream << indent_str;
    stream << "#endif";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    /*";
    stream << "\n";
    stream << indent_str;
    stream << "     * switch to M mode by invoking a write access fault for special address.";
    stream << "\n";
    stream << indent_str;
    stream << "     */ ";
    stream << "\n";
    stream << indent_str;
    stream << "    *(char *)(FAKE_ADDRESS) = 1;";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "static void checkTestResult() {";
    stream << "\n";
    stream << indent_str;
    stream << "    int ret = 0;";
    stream << "\n";
    stream << indent_str;
    stream << "    if (expected_r_fail != actual_r_fail) {";
    stream << "\n";
    stream << indent_str;
    stream << "        ret += 1;";
    stream << "\n";
    stream << indent_str;
    stream << "        printf(\"Read test fail, expected %d, actual %d.\\n\", expected_r_fail, actual_r_fail);";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "    if (expected_w_fail != actual_w_fail) {";
    stream << "\n";
    stream << indent_str;
    stream << "        ret += 2;";
    stream << "\n";
    stream << indent_str;
    stream << "        printf(\"Write test fail, expected %d, actual %d.\\n\", expected_w_fail, actual_w_fail);";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "    if (expected_x_fail != actual_x_fail) {";
    stream << "\n";
    stream << indent_str;
    stream << "        ret += 4;";
    stream << "\n";
    stream << indent_str;
    stream << "        printf(\"Fetch test fail, expected %d, actual %d.\\n\", expected_x_fail, actual_x_fail);";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    printf(\"Test done, exit %d.\\n\", ret);";
    stream << "\n";
    stream << indent_str;
    indent = 4;
    stream << "    ";
    indent = 0;
    stream << "\n";
    stream << indent_str;
    stream << "    exit(ret); ";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "int main() {";
    stream << "\n";
    stream << indent_str;
    stream << "    // assert in M mode";
    stream << "\n";
    stream << indent_str;
    stream << "    set_cfg();";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    switch_smode();";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    return 0; // assert 0";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
  }
};

#endif // SPMP_OK_SHARE_GEN_CLASS_H
